TODO
----

Intelligenter Umgang mit Aggregates/Entities
 - $domain->aggregate_name(42)          --> entspricht ->load(42)
 - $domain->aggregate_name($row_object) --> übernimmt row, setzt id, load_callbacks
 - $domain->aggregate_name({...})       --> übernimmt alles angegebene
 - $domain->aggregate_name(a => 42)     --> übernimmt alles angegebene

Factories zum Erzeugen von xxx

Einführen von Specifications
    * is_satisfied($obj): Bool

Idee: kann man eine Specification so erstellen, daß sie sowohl eine Bedingung
      testet, als auch die Bedingung DBIC-tauglich zurück liefert?
      --> "me." ==> Aufruf von methoden auf $obj.
      --> Alternativ: Query auslösen


--- Beispiel Entity

package Entity::Xxx;
use Moose;
extends 'DDD::Entity';

sub _resultset_name {
    'orderlist' 
}
sub _handles {
    qw(
        :all
        :columns
        :primary
        :relations
        name_of_method
        -name_of_method_to_ignore
    )
}
